## 网络组成     
+ CNN卷积层：使用深度 CNN对输入图像提取特征，得到特征图
+ map2seq：特征图到特征序列（由特征向量组成）    
+ RNN循环层：使用双向 RNN对特征序列进行预测，对序列中的每个特征向量进行学习并输出预测标签(真实值)分布  
+ CTC 转录层：使用 CTC 损失把从循环层获取的一系列标签分布转换成最终的标签序列

## cnn   
几点约束：   
+ 输入图像为灰度图像-单通道；       
+ 高度为32，这是固定的，**图片通过 CNN 后，高度就变为 1**，这点很重要；       
+ 宽度为160，宽度也可以为其他的值，但需要统一，所以输入 CNN 的数据尺寸为 **(channel, height, width)=(1, 32, 160)**       
+ CNN 的输出尺寸为 **(512, 1, 40)**，即 CNN 最后得到 512 个特征图，每个特征图的高度为 1，宽度为 40    

注意：  
最后的卷积层是一个 `2*2, s=1, p=0` 的卷积，此时相当于将 feature map 放缩为原来的 1/2，所以整个 CNN 层将图像的 h 放缩为原来的`1/(2^4)*2 = 1/32`，所以最后 CNN 输出的 feature map 的高度为1。   
```py
assert imgH % 16 == 0,'imgH has to be a multiple of 16'
```   
在程序中，图像的 h 必须为 16 的整数倍。    

```py   
assert h == 1, 'the height of conv must be 1'  
```

前向传播时，CNN 得到的 feature map 的 h 必须为 1。       
最后 CNN 得到的 feature map 尺度为 `512x1x40`     

## map2seq   
不能直接把 CNN 得到的特征图送入 RNN 进行训练的，需要进行一些调整，根据特征图提取 RNN 需要的特征向量序列。    
现在需要从 CNN 模型产生的特征图中提取特征向量序列，每一个特征向量（如图中的一个红色框）在特征图上**按列**从左到右生成，每一列包含 512 维特征，这意味着第 i 个特征向量是所有的特征图第 i 列像素的连接，这些特征向量就构成一个序列。 **一共有W个特征向量，这里W=40，每一个特征向量长度为512**。       

由于卷积层，最大池化层和激活函数在局部区域上执行，因此它们是平移不变的。因此，特征图的每列（即一个特征向量）对应于原始图像的一个矩形区域（称为感受野），并且这些矩形区域与特征图上从左到右的相应列具有相同的顺序。特征序列中的每个向量关联一个感受野。    
这些特征向量序列就作为循环层的输入，每个特征向量作为 RNN 在一个时间步（time step）的输入。    

## rnn   

## ctc loss  



